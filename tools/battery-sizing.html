<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battery Sizing Tool - Effekttariff Peak Shaving</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    .header-left h1 {
      margin: 0 0 5px 0;
      color: #1a1a1a;
    }
    .subtitle {
      color: #666;
      margin: 0;
    }
    .lang-switcher {
      display: flex;
      gap: 5px;
      background: #fff;
      padding: 4px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .lang-btn {
      padding: 6px 12px;
      border: none;
      background: transparent;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }
    .lang-btn.active {
      background: #2563eb;
      color: #fff;
    }
    .lang-btn:hover:not(.active) {
      background: #f0f0f0;
    }
    .layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 20px;
    }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .header { flex-direction: column; gap: 15px; }
    }
    .panel {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .panel h2 {
      margin: 0 0 15px 0;
      font-size: 16px;
      color: #333;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .control-group {
      margin-bottom: 18px;
    }
    .control-group label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 6px;
      color: #555;
    }
    .control-group .value {
      float: right;
      font-weight: 600;
      color: #2563eb;
    }
    .control-group small {
      color: #888;
      font-size: 11px;
    }
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #e0e0e0;
      outline: none;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    select {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: #fff;
    }
    .results-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    .result-card {
      background: #f8fafc;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .result-card.highlight {
      background: #dbeafe;
      border: 2px solid #2563eb;
    }
    .result-card .label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
    .result-card .value {
      font-size: 24px;
      font-weight: 700;
      color: #1a1a1a;
    }
    .result-card.highlight .value {
      color: #2563eb;
    }
    .result-card .unit {
      font-size: 14px;
      color: #666;
    }
    .chart-container {
      margin-bottom: 20px;
    }
    .chart-container h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #555;
    }
    .chart-container .chart-desc {
      font-size: 12px;
      color: #666;
      margin: 0 0 10px 0;
    }
    canvas {
      max-height: 250px;
    }
    .info-box {
      background: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 8px;
      padding: 12px;
      font-size: 13px;
      margin-top: 15px;
    }
    .info-box strong {
      color: #92400e;
    }
    .disclaimer-box {
      background: #fef2f2;
      border: 1px solid #fca5a5;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      margin-top: 20px;
      color: #991b1b;
    }
    .disclaimer-box strong {
      color: #7f1d1d;
    }
    .toggle-group {
      display: flex;
      gap: 10px;
      margin-bottom: 18px;
    }
    .toggle-btn {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    .toggle-btn.active {
      border-color: #2563eb;
      background: #eff6ff;
      color: #2563eb;
      font-weight: 600;
    }
    .section-divider {
      border-top: 1px solid #eee;
      margin: 20px 0;
      padding-top: 15px;
    }
    .comparison-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }
    .bar-label {
      width: 100px;
      font-size: 12px;
      color: #666;
    }
    .bar-container {
      flex: 1;
      height: 24px;
      background: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
    }
    .bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .bar-fill.without { background: #ef4444; }
    .bar-fill.with { background: #22c55e; }
    .bar-value {
      width: 70px;
      text-align: right;
      font-weight: 600;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 data-i18n="title">Battery Sizing Tool</h1>
        <p class="subtitle" data-i18n="subtitle">Simulate how a battery can reduce your effekttariff peaks</p>
      </div>
      <div class="lang-switcher">
        <button class="lang-btn active" data-lang="en">English</button>
        <button class="lang-btn" data-lang="sv">Svenska</button>
      </div>
    </div>

    <div class="layout">
      <div class="panel">
        <h2 data-i18n="batterySettings">Battery Settings</h2>

        <div class="control-group">
          <label><span data-i18n="batteryCapacity">Battery Capacity</span> <span class="value" id="capacityValue">10 kWh</span></label>
          <input type="range" id="capacity" min="5" max="50" step="1" value="10">
        </div>

        <div class="control-group">
          <label><span data-i18n="minSoc">Min SOC (reserve)</span> <span class="value" id="minSocValue">10%</span></label>
          <input type="range" id="minSoc" min="5" max="30" step="5" value="10">
        </div>

        <div class="control-group">
          <label><span data-i18n="chargeTo">Charge to (%)</span> <span class="value" id="targetSocValue">90%</span></label>
          <input type="range" id="targetSoc" min="50" max="100" step="5" value="90">
          <small data-i18n="chargeToHelp">Target SOC before peak hours start</small>
        </div>

        <div class="control-group">
          <label><span data-i18n="maxRate">Max Charge/Discharge Rate</span> <span class="value" id="maxRateValue">5 kW</span></label>
          <input type="range" id="maxRate" min="1" max="15" step="0.5" value="5">
        </div>

        <div class="section-divider">
          <h2 style="border:none; padding:0;" data-i18n="consumptionProfile">Consumption Profile</h2>
        </div>

        <div class="control-group">
          <label data-i18n="profileType">Profile Type</label>
          <select id="profile">
            <option value="typical" data-i18n-option="profileTypical">Typical Swedish Household</option>
            <option value="ev" data-i18n-option="profileEv">Household + EV Charging</option>
            <option value="heatpump" data-i18n-option="profileHeatpump">Household + Heat Pump</option>
            <option value="custom" data-i18n-option="profileCustom">Custom</option>
          </select>
        </div>

        <div id="customInputs" style="display: none;">
          <div class="control-group">
            <label><span data-i18n="baseLoad">Base Load</span> <span class="value" id="baseLoadValue">1.5 kW</span></label>
            <input type="range" id="baseLoad" min="0.5" max="5" step="0.1" value="1.5">
          </div>
          <div class="control-group">
            <label><span data-i18n="peakLoad">Peak Load</span> <span class="value" id="peakLoadValue">4 kW</span></label>
            <input type="range" id="peakLoad" min="2" max="15" step="0.5" value="4">
          </div>
        </div>

        <div class="section-divider">
          <h2 style="border:none; padding:0;" data-i18n="providerSettings">Provider Settings</h2>
        </div>

        <div class="control-group">
          <label data-i18n="peakHours">Peak Hours</label>
          <select id="peakHours">
            <option value="7-21">07:00 - 21:00 (Kungälv Energi)</option>
            <option value="7-19">07:00 - 19:00 (Ellevio)</option>
            <option value="6-22">06:00 - 22:00 (Extended)</option>
          </select>
        </div>

        <div class="control-group">
          <label><span data-i18n="numberOfPeaks">Number of Peaks</span> <span class="value" id="peakCountValue">3</span></label>
          <input type="range" id="peakCount" min="2" max="5" step="1" value="3">
        </div>

        <div class="section-divider">
          <h2 style="border:none; padding:0;" data-i18n="electricalInstallation">Electrical Installation</h2>
        </div>

        <div class="control-group">
          <label data-i18n="numberOfPhases">Number of Phases</label>
          <div class="toggle-group">
            <button class="toggle-btn" data-phases="1" id="phase1" data-i18n="phase1">1-phase</button>
            <button class="toggle-btn active" data-phases="3" id="phase3" data-i18n="phase3">3-phase</button>
          </div>
        </div>

        <div class="control-group">
          <label><span data-i18n="mainBreaker">Main Breaker</span> <span class="value" id="breakerValue">25 A</span></label>
          <input type="range" id="breaker" min="16" max="35" step="1" value="25">
          <small><span data-i18n="maxCapacity">Max capacity</span>: <span id="maxCapacity">17.3 kW</span></small>
        </div>

        <div class="control-group">
          <label><span data-i18n="minimumLimit">Minimum Limit</span> <span class="value" id="minLimitValue">2 kW</span></label>
          <input type="range" id="minLimit" min="1" max="6" step="0.5" value="2">
        </div>

        <div class="info-box">
          <strong data-i18n="usableCapacity">Usable Capacity:</strong> <span id="usableCapacity">8.0 kWh</span><br>
          <small data-i18n="usableCapacityHelp">Based on Charge to - Min SOC</small>
        </div>
      </div>

      <div>
        <div class="panel">
          <h2 data-i18n="resultsTitle">Results - 7 Day Simulation</h2>

          <div class="results-grid">
            <div class="result-card">
              <div class="label" data-i18n="withoutBattery">Without Battery</div>
              <div class="value" id="peakWithout">-</div>
              <div class="unit" data-i18n="peakAvgUnit">kW peak avg</div>
            </div>
            <div class="result-card">
              <div class="label" data-i18n="withBattery">With Battery</div>
              <div class="value" id="peakWith">-</div>
              <div class="unit" data-i18n="peakAvgUnit">kW peak avg</div>
            </div>
            <div class="result-card highlight">
              <div class="label" data-i18n="reduction">Reduction</div>
              <div class="value" id="reduction">-</div>
              <div class="unit">%</div>
            </div>
          </div>

          <div class="comparison-bar">
            <div class="bar-label" data-i18n="withoutBattery">Without Battery</div>
            <div class="bar-container">
              <div class="bar-fill without" id="barWithout" style="width: 0%"></div>
            </div>
            <div class="bar-value" id="barValueWithout">-</div>
          </div>
          <div class="comparison-bar">
            <div class="bar-label" data-i18n="withBattery">With Battery</div>
            <div class="bar-container">
              <div class="bar-fill with" id="barWith" style="width: 0%"></div>
            </div>
            <div class="bar-value" id="barValueWith">-</div>
          </div>

          <div class="disclaimer-box">
            <strong data-i18n="disclaimerTitle">Important:</strong>
            <span data-i18n="disclaimerText">These results are theoretical estimates based on simplified consumption patterns. Actual savings depend on your real consumption behavior, battery efficiency, grid conditions, and other factors. Use this tool for guidance only.</span>
          </div>
        </div>

        <div class="panel" style="margin-top: 20px;">
          <div class="chart-container">
            <h3 data-i18n="powerChartTitle">Grid Consumption with Battery (Day 4)</h3>
            <p class="chart-desc" data-i18n="powerChartDesc">Blue = power drawn from grid after battery discharge. Red = limit (lower during peak hours).</p>
            <canvas id="powerChart"></canvas>
          </div>
        </div>

        <div class="panel" style="margin-top: 20px;">
          <div class="chart-container">
            <h3 data-i18n="socChartTitle">Battery State of Charge (Day 4)</h3>
            <p class="chart-desc" data-i18n="socChartDesc">Battery charges overnight and discharges during peak hours to reduce grid consumption.</p>
            <canvas id="socChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Translations
    const translations = {
      en: {
        title: 'Battery Sizing Tool',
        subtitle: 'Simulate how a battery can reduce your effekttariff peaks',
        batterySettings: 'Battery Settings',
        batteryCapacity: 'Battery Capacity',
        minSoc: 'Min SOC (reserve)',
        chargeTo: 'Charge to (%)',
        chargeToHelp: 'Target SOC before peak hours start',
        maxRate: 'Max Charge/Discharge Rate',
        consumptionProfile: 'Consumption Profile',
        profileType: 'Profile Type',
        profileTypical: 'Typical Swedish Household',
        profileEv: 'Household + EV Charging',
        profileHeatpump: 'Household + Heat Pump',
        profileCustom: 'Custom',
        baseLoad: 'Base Load',
        peakLoad: 'Peak Load',
        providerSettings: 'Provider Settings',
        peakHours: 'Peak Hours',
        numberOfPeaks: 'Number of Peaks',
        electricalInstallation: 'Electrical Installation',
        numberOfPhases: 'Number of Phases',
        phase1: '1-phase',
        phase3: '3-phase',
        mainBreaker: 'Main Breaker',
        maxCapacity: 'Max capacity',
        minimumLimit: 'Minimum Limit',
        usableCapacity: 'Usable Capacity:',
        usableCapacityHelp: 'Based on Charge to - Min SOC',
        resultsTitle: 'Results - 7 Day Simulation',
        withoutBattery: 'Without Battery',
        withBattery: 'With Battery',
        reduction: 'Reduction',
        peakAvgUnit: 'kW peak avg',
        disclaimerTitle: 'Important:',
        disclaimerText: 'These results are theoretical estimates based on simplified consumption patterns. Actual savings depend on your real consumption behavior, battery efficiency, grid conditions, and other factors. Use this tool for guidance only.',
        powerChartTitle: 'Grid Consumption with Battery (Day 4)',
        powerChartDesc: 'Blue = power drawn from grid after battery discharge. Red = limit (lower during peak hours).',
        socChartTitle: 'Battery State of Charge (Day 4)',
        socChartDesc: 'Battery charges overnight and discharges during peak hours to reduce grid consumption.',
        chartGridConsumption: 'Grid consumption (with battery)',
        chartPowerLimit: 'Power limit',
        chartBatteryLevel: 'Battery charge level',
        chartPowerAxis: 'Power (W)',
        chartSocAxis: 'State of Charge (%)'
      },
      sv: {
        title: 'Batteridimensionering',
        subtitle: 'Simulera hur ett batteri kan minska dina effekttoppar',
        batterySettings: 'Batteriinställningar',
        batteryCapacity: 'Batterikapacitet',
        minSoc: 'Min SOC (reserv)',
        chargeTo: 'Ladda till (%)',
        chargeToHelp: 'Mål-SOC innan höglasttimmar börjar',
        maxRate: 'Max ladd-/urladdningshastighet',
        consumptionProfile: 'Förbrukningsprofil',
        profileType: 'Profiltyp',
        profileTypical: 'Typiskt svenskt hushåll',
        profileEv: 'Hushåll + elbilsladdning',
        profileHeatpump: 'Hushåll + värmepump',
        profileCustom: 'Anpassad',
        baseLoad: 'Basförbrukning',
        peakLoad: 'Toppförbrukning',
        providerSettings: 'Nätägare',
        peakHours: 'Höglasttimmar',
        numberOfPeaks: 'Antal toppar',
        electricalInstallation: 'Elinstallation',
        numberOfPhases: 'Antal faser',
        phase1: '1-fas',
        phase3: '3-fas',
        mainBreaker: 'Huvudsäkring',
        maxCapacity: 'Max kapacitet',
        minimumLimit: 'Minimigräns',
        usableCapacity: 'Användbar kapacitet:',
        usableCapacityHelp: 'Baserat på Ladda till - Min SOC',
        resultsTitle: 'Resultat - 7 dagars simulering',
        withoutBattery: 'Utan batteri',
        withBattery: 'Med batteri',
        reduction: 'Minskning',
        peakAvgUnit: 'kW toppsnitt',
        disclaimerTitle: 'Viktigt:',
        disclaimerText: 'Dessa resultat är teoretiska uppskattningar baserade på förenklade förbrukningsmönster. Verkliga besparingar beror på din faktiska förbrukning, batteriets verkningsgrad, nätförhållanden och andra faktorer. Använd detta verktyg endast som vägledning.',
        powerChartTitle: 'Nätförbrukning med batteri (dag 4)',
        powerChartDesc: 'Blå = effekt från nätet efter batteriurladdning. Röd = gräns (lägre under höglasttimmar).',
        socChartTitle: 'Batteriets laddningsnivå (dag 4)',
        socChartDesc: 'Batteriet laddas på natten och laddar ur under höglasttimmar för att minska nätförbrukningen.',
        chartGridConsumption: 'Nätförbrukning (med batteri)',
        chartPowerLimit: 'Effektgräns',
        chartBatteryLevel: 'Batteriets laddningsnivå',
        chartPowerAxis: 'Effekt (W)',
        chartSocAxis: 'Laddningsnivå (%)'
      }
    };

    let currentLang = localStorage.getItem('batterySizingLang') || 'en';

    function applyTranslations(lang) {
      currentLang = lang;
      localStorage.setItem('batterySizingLang', lang);
      document.documentElement.lang = lang;

      const t = translations[lang];

      // Update all elements with data-i18n attribute
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (t[key]) {
          el.textContent = t[key];
        }
      });

      // Update select options
      document.querySelectorAll('[data-i18n-option]').forEach(el => {
        const key = el.dataset.i18nOption;
        if (t[key]) {
          el.textContent = t[key];
        }
      });

      // Update language buttons
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });

      // Update page title
      document.title = lang === 'sv'
        ? 'Batteridimensionering - Effekttariff'
        : 'Battery Sizing Tool - Effekttariff Peak Shaving';

      // Reinitialize charts with translated labels
      if (powerChart && socChart) {
        updateChartLabels(lang);
      }
    }

    function updateChartLabels(lang) {
      const t = translations[lang];

      powerChart.data.datasets[0].label = t.chartGridConsumption;
      powerChart.data.datasets[1].label = t.chartPowerLimit;
      powerChart.options.scales.y.title.text = t.chartPowerAxis;
      powerChart.update();

      socChart.data.datasets[0].label = t.chartBatteryLevel;
      socChart.options.scales.y.title.text = t.chartSocAxis;
      socChart.update();
    }

    // Consumption profiles
    const profiles = {
      typical: { base: 1500, peak: 3500 },
      ev: { base: 2000, peak: 8000 },
      heatpump: { base: 2500, peak: 6000 },
      custom: { base: 1500, peak: 4000 }
    };

    // Daily consumption pattern (Swedish household)
    function getDailyPattern(hour, baseW, peakW) {
      if (hour >= 0 && hour < 6) return baseW * 0.5;      // Night
      if (hour >= 6 && hour < 9) return baseW + (peakW - baseW) * 0.75;  // Morning peak
      if (hour >= 9 && hour < 17) return baseW * 0.8;     // Day
      if (hour >= 17 && hour < 21) return peakW;          // Evening peak
      return baseW * 0.6;                                  // Late evening
    }

    // Run simulation
    function runSimulation(config) {
      const {
        batteryCapacityWh,
        minSoc,
        targetSoc,
        maxRateW,
        baseW,
        peakW,
        peakHoursStart,
        peakHoursEnd,
        peakCount,
        minimumLimitW,
        batteryEnabled
      } = config;

      const durationDays = 7;
      const samplesPerHour = 6;
      const intervalHours = 1 / samplesPerHour;
      const totalSamples = durationDays * 24 * samplesPerHour;

      let currentSoc = batteryEnabled ? targetSoc : 0;
      const peaks = [];
      const hourlyData = [];
      const socData = [];

      let currentHour = -1;
      let hourSum = 0;
      let hourSamples = 0;

      for (let i = 0; i < totalSamples; i++) {
        const totalHours = i / samplesPerHour;
        const hour = Math.floor(totalHours) % 24;
        const day = Math.floor(totalHours / 24);

        // Generate raw power
        const rawPower = getDailyPattern(hour, baseW, peakW);

        // Determine if in peak hours
        const inPeakHours = hour >= peakHoursStart && hour < peakHoursEnd;

        // Battery simulation
        let effectivePower = rawPower;
        let socChange = 0;

        if (batteryEnabled) {
          if (inPeakHours) {
            // Discharge to minimize grid consumption
            const excessPower = rawPower - minimumLimitW;
            if (excessPower > 0 && currentSoc > minSoc) {
              const availableEnergyWh = (currentSoc - minSoc) / 100 * batteryCapacityWh;
              const maxDischarge = Math.min(maxRateW, availableEnergyWh / intervalHours, excessPower);
              const discharge = Math.max(0, maxDischarge);
              const energyWh = discharge * intervalHours;
              socChange = -(energyWh / batteryCapacityWh) * 100;
              effectivePower = Math.max(0, rawPower - discharge);
            }
          } else {
            // Charge during off-peak
            if (currentSoc < targetSoc) {
              let hoursUntilPeak = peakHoursStart - hour;
              if (hoursUntilPeak <= 0) hoursUntilPeak += 24;
              const energyDeficitWh = (targetSoc - currentSoc) / 100 * batteryCapacityWh;
              const requiredRate = energyDeficitWh / hoursUntilPeak;
              const chargeRate = Math.min(maxRateW, Math.max(0, requiredRate));
              const energyWh = chargeRate * intervalHours;
              socChange = (energyWh / batteryCapacityWh) * 100;
            }
          }
          currentSoc = Math.max(minSoc, Math.min(100, currentSoc + socChange));
        }

        // Track hourly data
        if (hour !== currentHour && currentHour !== -1 && hourSamples > 0) {
          const avgW = hourSum / hourSamples;
          hourlyData.push({ hour: currentHour, avgW, day: Math.floor((i - 1) / samplesPerHour / 24) });

          // Record peak if in peak hours
          const wasInPeakHours = currentHour >= peakHoursStart && currentHour < peakHoursEnd;
          if (wasInPeakHours) {
            const peakDay = hourlyData[hourlyData.length - 1].day;
            const existingIdx = peaks.findIndex(p => p.day === peakDay);
            if (existingIdx >= 0) {
              if (avgW > peaks[existingIdx].avgW) {
                peaks[existingIdx] = { day: peakDay, hour: currentHour, avgW };
              }
            } else {
              peaks.push({ day: peakDay, hour: currentHour, avgW });
            }
          }
        }

        if (hour !== currentHour) {
          currentHour = hour;
          hourSum = 0;
          hourSamples = 0;
        }

        hourSum += effectivePower;
        hourSamples++;

        // Track SOC for day 4 (record at end of each hour)
        if (day === 3) {
          const existingSoc = socData.find(s => s.hour === hour);
          if (!existingSoc) {
            socData.push({ hour, soc: currentSoc });
          } else {
            existingSoc.soc = currentSoc;
          }
        }
      }

      // Calculate peak average
      peaks.sort((a, b) => b.avgW - a.avgW);
      const topPeaks = peaks.slice(0, peakCount);
      const peakAvgW = topPeaks.length > 0
        ? topPeaks.reduce((sum, p) => sum + p.avgW, 0) / topPeaks.length
        : 0;

      // Get day 4 data for charts
      const day4Data = hourlyData.filter(h => h.day === 3);

      return {
        peakAvgKw: peakAvgW / 1000,
        topPeaks,
        day4Data,
        socData: batteryEnabled ? socData : []
      };
    }

    // Charts
    let powerChart, socChart;

    function initCharts() {
      const t = translations[currentLang];

      const powerCtx = document.getElementById('powerChart').getContext('2d');
      powerChart = new Chart(powerCtx, {
        type: 'line',
        data: {
          labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
          datasets: [
            {
              label: t.chartGridConsumption,
              data: [],
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              fill: true,
              tension: 0.3
            },
            {
              label: t.chartPowerLimit,
              data: [],
              borderColor: '#ef4444',
              borderWidth: 2,
              borderDash: [5, 5],
              stepped: true,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { intersect: false, mode: 'index' },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: t.chartPowerAxis } }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: ctx => `${ctx.dataset.label}: ${(ctx.parsed.y / 1000).toFixed(2)} kW`
              }
            }
          }
        }
      });

      const socCtx = document.getElementById('socChart').getContext('2d');
      socChart = new Chart(socCtx, {
        type: 'line',
        data: {
          labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
          datasets: [{
            label: t.chartBatteryLevel,
            data: [],
            borderColor: '#22c55e',
            backgroundColor: 'rgba(34, 197, 94, 0.2)',
            fill: true,
            tension: 0.3,
            pointRadius: 2
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { min: 0, max: 100, title: { display: true, text: t.chartSocAxis } }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: ctx => `SOC: ${ctx.parsed.y?.toFixed(1) || 0}%`
              }
            }
          }
        }
      });
    }

    function updateCharts(resultsWith, config) {
      const maxBreakerW = config.breakerA * config.phases * 230;

      const consumptionData = resultsWith.day4Data.map(d => d.avgW);
      const limitData = Array.from({ length: 24 }, (_, hour) => {
        const inPeak = hour >= config.peakHoursStart && hour < config.peakHoursEnd;
        return inPeak ? config.minimumLimitW : maxBreakerW;
      });

      powerChart.data.datasets[0].data = consumptionData;
      powerChart.data.datasets[1].data = limitData;
      powerChart.update();

      if (resultsWith.socData.length > 0) {
        const sortedSoc = resultsWith.socData.sort((a, b) => a.hour - b.hour);
        const socValues = Array(24).fill(null);
        sortedSoc.forEach(d => {
          socValues[d.hour] = d.soc;
        });
        for (let i = 0; i < 24; i++) {
          if (socValues[i] === null) {
            let prev = i - 1;
            while (prev >= 0 && socValues[prev] === null) prev--;
            let next = i + 1;
            while (next < 24 && socValues[next] === null) next++;
            if (prev >= 0 && next < 24) {
              socValues[i] = (socValues[prev] + socValues[next]) / 2;
            } else if (prev >= 0) {
              socValues[i] = socValues[prev];
            } else if (next < 24) {
              socValues[i] = socValues[next];
            }
          }
        }
        socChart.data.datasets[0].data = socValues;
        socChart.update();
      } else {
        socChart.data.datasets[0].data = [];
        socChart.update();
      }
    }

    function updateResults() {
      const capacity = parseFloat(document.getElementById('capacity').value);
      const minSoc = parseFloat(document.getElementById('minSoc').value);
      const targetSoc = parseFloat(document.getElementById('targetSoc').value);
      const maxRate = parseFloat(document.getElementById('maxRate').value);
      const peakCount = parseInt(document.getElementById('peakCount').value);
      const minLimit = parseFloat(document.getElementById('minLimit').value);
      const breakerA = parseInt(document.getElementById('breaker').value);
      const phases = parseInt(document.querySelector('.toggle-btn.active[data-phases]')?.dataset.phases || 3);

      const profileId = document.getElementById('profile').value;
      let baseW, peakW;
      if (profileId === 'custom') {
        baseW = parseFloat(document.getElementById('baseLoad').value) * 1000;
        peakW = parseFloat(document.getElementById('peakLoad').value) * 1000;
      } else {
        baseW = profiles[profileId].base;
        peakW = profiles[profileId].peak;
      }

      const peakHoursStr = document.getElementById('peakHours').value;
      const [peakHoursStart, peakHoursEnd] = peakHoursStr.split('-').map(Number);

      // Update display values
      document.getElementById('capacityValue').textContent = `${capacity} kWh`;
      document.getElementById('minSocValue').textContent = `${minSoc}%`;
      document.getElementById('targetSocValue').textContent = `${targetSoc}%`;
      document.getElementById('maxRateValue').textContent = `${maxRate} kW`;
      document.getElementById('peakCountValue').textContent = peakCount;
      document.getElementById('minLimitValue').textContent = `${minLimit} kW`;
      document.getElementById('baseLoadValue').textContent = `${(baseW / 1000).toFixed(1)} kW`;
      document.getElementById('peakLoadValue').textContent = `${(peakW / 1000).toFixed(1)} kW`;
      document.getElementById('breakerValue').textContent = `${breakerA} A`;
      const maxCapacityKw = (breakerA * phases * 230) / 1000;
      document.getElementById('maxCapacity').textContent = `${maxCapacityKw.toFixed(1)} kW`;

      const usableCapacity = (targetSoc - minSoc) / 100 * capacity;
      document.getElementById('usableCapacity').textContent = `${usableCapacity.toFixed(1)} kWh`;

      const config = {
        batteryCapacityWh: capacity * 1000,
        minSoc,
        targetSoc,
        maxRateW: maxRate * 1000,
        baseW,
        peakW,
        peakHoursStart,
        peakHoursEnd,
        peakCount,
        minimumLimitW: minLimit * 1000,
        breakerA,
        phases
      };

      const resultsWithout = runSimulation({ ...config, batteryEnabled: false });
      const resultsWith = runSimulation({ ...config, batteryEnabled: true });

      const peakWithout = resultsWithout.peakAvgKw;
      const peakWith = resultsWith.peakAvgKw;
      const reduction = peakWithout > 0 ? ((peakWithout - peakWith) / peakWithout * 100) : 0;

      document.getElementById('peakWithout').textContent = peakWithout.toFixed(2);
      document.getElementById('peakWith').textContent = peakWith.toFixed(2);
      document.getElementById('reduction').textContent = reduction.toFixed(0);

      const maxPeak = Math.max(peakWithout, peakWith, 1);
      document.getElementById('barWithout').style.width = `${(peakWithout / maxPeak) * 100}%`;
      document.getElementById('barWith').style.width = `${(peakWith / maxPeak) * 100}%`;
      document.getElementById('barValueWithout').textContent = `${peakWithout.toFixed(2)} kW`;
      document.getElementById('barValueWith').textContent = `${peakWith.toFixed(2)} kW`;

      updateCharts(resultsWith, config);
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      // Apply saved language or detect from browser
      const savedLang = localStorage.getItem('batterySizingLang');
      const browserLang = navigator.language.startsWith('sv') ? 'sv' : 'en';
      applyTranslations(savedLang || browserLang);

      initCharts();

      // Language switcher
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          applyTranslations(btn.dataset.lang);
        });
      });

      // Input listeners
      const inputs = ['capacity', 'minSoc', 'targetSoc', 'maxRate', 'peakCount', 'minLimit', 'baseLoad', 'peakLoad', 'breaker'];
      inputs.forEach(id => {
        document.getElementById(id).addEventListener('input', updateResults);
      });

      // Phase toggle buttons
      document.querySelectorAll('.toggle-btn[data-phases]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.toggle-btn[data-phases]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          updateResults();
        });
      });

      document.getElementById('profile').addEventListener('change', (e) => {
        const customInputs = document.getElementById('customInputs');
        if (e.target.value === 'custom') {
          customInputs.style.display = 'block';
        } else {
          customInputs.style.display = 'none';
          const profile = profiles[e.target.value];
          document.getElementById('baseLoad').value = profile.base / 1000;
          document.getElementById('peakLoad').value = profile.peak / 1000;
        }
        updateResults();
      });

      document.getElementById('peakHours').addEventListener('change', updateResults);

      // Initial run
      updateResults();
    });
  </script>
</body>
</html>
